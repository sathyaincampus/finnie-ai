"""
Finnie AI â€” Base Agent Class

Abstract base class that all Finnie agents inherit from.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Optional

from src.orchestration.state import FinnieState


@dataclass
class AgentResult:
    """Standardized result from an agent."""
    
    content: str
    """The text content generated by the agent."""
    
    data: Optional[dict] = None
    """Structured data (market data, calculations, etc.)."""
    
    visualizations: list[dict] = field(default_factory=list)
    """Charts or visualizations to display."""
    
    disclaimers: list[str] = field(default_factory=list)
    """Compliance disclaimers (for Guardian)."""
    
    confidence: float = 1.0
    """Confidence score (0-1)."""
    
    sources: list[str] = field(default_factory=list)
    """Sources used for the response."""


class BaseFinnieAgent(ABC):
    """
    Abstract base class for Finnie AI agents.
    
    Each agent specializes in a specific domain:
    - Quant: Market data and technicals
    - Professor: Financial education
    - Analyst: News and research
    - Advisor: Portfolio management
    - Guardian: Compliance
    - Scribe: Response synthesis
    - Oracle: Projections
    - Scout: Trend discovery
    
    Subclasses must implement:
    - name: Agent identifier
    - description: What the agent does
    - system_prompt: The agent's personality/role
    - process(): Main processing logic
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Unique agent identifier (e.g., 'quant')."""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Brief description of the agent's role."""
        pass
    
    @property
    @abstractmethod
    def system_prompt(self) -> str:
        """System prompt that defines the agent's behavior."""
        pass
    
    @property
    def emoji(self) -> str:
        """Emoji icon for the agent (for display)."""
        return "ğŸ¤–"
    
    @abstractmethod
    async def process(self, state: FinnieState) -> dict[str, Any]:
        """
        Process the user's request.
        
        Args:
            state: The current workflow state with user input and context.
            
        Returns:
            Dict with keys:
            - content: str - The agent's response text
            - data: Optional[dict] - Structured data
            - visualizations: Optional[list] - Charts to display
            - disclaimers: Optional[list] - Compliance messages
        """
        pass
    
    async def _call_llm(
        self,
        state: FinnieState,
        messages: list[dict],
        system_prompt: Optional[str] = None,
    ) -> str:
        """
        Helper to call the LLM using state's configuration.
        
        Args:
            state: Workflow state with LLM configuration.
            messages: Messages to send.
            system_prompt: Override system prompt.
            
        Returns:
            The LLM's response text.
        """
        from src.llm import get_llm_adapter
        
        adapter = get_llm_adapter(
            provider=state.get("llm_provider", "openai"),
            model=state.get("llm_model", "gpt-4o"),
            api_key=state.get("llm_api_key", ""),
        )
        
        response = await adapter.chat(
            messages=messages,
            system_prompt=system_prompt or self.system_prompt,
        )
        
        return response.content
    
    def _extract_tickers(self, text: str) -> list[str]:
        """
        Extract stock ticker symbols from text.
        
        Uses a whitelist approach:
        - $AAPL â€” always treated as a ticker
        - BRK-A / BRK.B â€” hyphenated/dotted always treated as tickers
        - AAPL â€” bare uppercase words only match KNOWN popular tickers
        """
        import re
        upper_text = text.upper()
        tickers = []

        KNOWN_TICKERS = {
            "SPY", "QQQ", "DIA", "IWM", "VTI", "VOO", "ARKK", "XLF", "XLE", "XLK",
            "AAPL", "MSFT", "GOOGL", "GOOG", "AMZN", "META", "NVDA", "TSLA",
            "JPM", "JNJ", "UNH", "PG", "HD", "BAC", "WMT", "KO", "PEP", "MCD",
            "DIS", "NFLX", "PYPL", "SQ", "SHOP", "UBER", "LYFT", "SNAP", "PINS",
            "AMD", "INTC", "CRM", "ORCL", "IBM", "CSCO", "QCOM", "AVGO", "TXN",
            "BA", "GE", "CAT", "MMM", "GS", "MS", "C", "WFC", "V", "MA", "AXP",
            "PFE", "MRNA", "ABBV", "BMY", "LLY", "MRK", "AMGN", "GILD",
            "XOM", "CVX", "COP", "SLB", "OXY",
            "COST", "TGT", "LOW", "SBUX", "NKE", "LULU",
            "COIN", "HOOD", "PLTR", "SOFI", "RIVN", "LCID", "NIO",
            "F", "GM", "TM", "ABNB", "BKNG", "MAR",
            "MSTR", "MARA", "RIOT",
        }

        # Pattern 1: $-prefixed (always a ticker)
        for m in re.finditer(r'\$([A-Z]{1,5})(?:[\-\.]([A-Z]{1,2}))?\b', upper_text):
            ticker = f"{m.group(1)}-{m.group(2)}" if m.group(2) else m.group(1)
            if ticker not in tickers:
                tickers.append(ticker)

        # Pattern 2: Hyphenated/dotted (always a ticker)
        for m in re.finditer(r'\b([A-Z]{1,5})[\-\.]([A-Z]{1,2})\b', upper_text):
            ticker = f"{m.group(1)}-{m.group(2)}"
            if ticker not in tickers:
                tickers.append(ticker)

        # Pattern 3: Bare words â€” only match KNOWN_TICKERS
        hyph_parts = set()
        for t in tickers:
            hyph_parts.update(t.split('-'))

        for m in re.finditer(r'\b([A-Z]{1,5})\b', upper_text):
            word = m.group(1)
            if word in KNOWN_TICKERS and word not in tickers and word not in hyph_parts:
                tickers.append(word)
        
        return tickers
    
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name='{self.name}')>"
